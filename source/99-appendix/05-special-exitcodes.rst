附录 E. 带有特殊意义的退出代码
==================================================

.. list-table:: 表 E-1: 预留的退出代码
   :header-rows: 1

   * - 退出代码
     - 表意
     - 示例
     - 注释
   * - 1
     - 通用错误
     - ``let "var1 = 1/0"``
     - 其他错误，如除以零错误及其他无权限操作。
   * - 2
     - (据 Bash 文档) 误用 Shell builtins 
     - ``empty_function() {}``
     - 缺失关键词或指令，或权限问题 (及 diff 在二进制文件比较时的返回值)
   * - 126
     - 调用的指令无法执行
     - ``/dev/null``
     - 权限问题或命令不可执行
   * - 127
     - 「未找到指令」
     - ``illegal_command``
     - 可能是 ``$PATH`` 有问题或输入有误。
   * - 128
     - exit 的参数有误
     - ``exit 3.14159``
     - **exit** 只接受范围在 0 - 255 的整数 (见第一个脚注)
   * - 128+n
     - 错误信号 "n"
     - 脚本的 ``kill -9 $PPID``
     - **$?** 返回 137 (128 + 9)
   * - 130
     - 脚本被 :kbd:`Control-C` 终止
     - :kbd:`Ctl-C`
     - :kbd:`Control-C` 是错误信号 2 (130 = 128 + 2, 见上)
   * - 255\*
     - 错误状态超范围
     - ``exit -1``
     - **exit** 只接受范围在 0 - 255 的整数

根据上表，退出代码 1 - 2，126 - 165 及 255 [#]_ 有特别含义，并因此应避免用于用户定义的退出代码。以 *exit 127* 结束代码一定会在调试时导致混乱 (这是「命令未找到」的错误代码还是用户定义的？)。然而，许多脚本把 *exit 1* 当作出错通用退出指令。因为退出代码 1 表示许多可能的错误，这对调试不是很有用。

对此曾有过系统化退出代码的尝试 (见 ``/usr/include/sysexits.h``)，但这是为了 C/C++ 程序员的。脚本中类似的标准可能比较恰当。文档作者提议限制用户定义的错误代码为 64 - 113 (包括表示成功的 0)，以符合 C/C++ 标准。这会分配 50 个可用代码，也会使脚本排错更直观。 [#]_ 本文档中所有脚本示例符合这个标准，除了需要违反这一点的情况，如 例 9-2。

.. note::
   
   只有在 Bash 或 *sh* 提示符中，Shell 脚本退出后在命令行执行 $? 才会给出与上表一致的结果，运行 *C-shell* 或 *tcsh* 有时会给出不同的结果。

脚注
--------------------------------------------------

.. [#] 超范围退出值会产生预料之外的退出代码。大于 255 的错误值会返回错误代码除以 256 的余数。例如， *exit 3809* 会导致错误代码 225 (3809 % 256 = 225)。
.. [#] ``/usr/include/sysexits.h`` 分配了此前未使用的从 64 到 78 的错误代码。可以预期的是未来未分配的错误代码的范围将继续被限制。文档作者 *不会* 为符合变化的标准更新代码。这不应导致任何问题，因为编译的 C/C++ 程序和 Shell 脚本在使用错误代码时没有重叠或冲突。
